import "std/Prelude.oj"
import "std/Read.oj"

class IntExpr(int)
class AddExpr(lhs, rhs)
class MulExpr(lhs, rhs)
class IdentExpr(name)
class LambdaExpr(name, expr)
class ApplyExpr(fn, arg)

class Env(get)

def Env.insert(name, value)
    Env((n) {n == name}.if(value, this.get(name)))

def local(name, value, lazy f)
    handle (f()) (n)
        {n == name}.if(local(name, value) { resume(value) }, do name)

def Any.eval() match (this) {
    IntExpr(int) int
    AddExpr(lhs, rhs) lhs.eval() + rhs.eval()
    MulExpr(lhs, rhs) lhs.eval() * rhs.eval()
    IdentExpr(name) do name
    LambdaExpr(name, expr) (arg) local(name, arg) { expr.eval() }
    ApplyExpr(fn, arg) fn.eval()(arg.eval())
}

def Any.evalRoot() 
    handle (this.eval()) (n)
        do {"undefined " + n}

def IntExpr.toString() "Expr(" + this.int.toString() + ")"
def AddExpr.toString() "Expr(" + this.lhs.toString() + " + " + this.rhs.toString() + ")"
def MulExpr.toString() "Expr(" + this.lhs.toString() + " * " + this.rhs.toString() + ")"
def IdentExpr.toString() "Expr(" + this.name + ")"
def LambdaExpr.toString() "Expr(Î»" + this.name + " " + this.expr.toString() + ")"
def ApplyExpr.toString() "Expr(" + this.fn.toString() + " $ " + this.arg.toString() + ")"

def charToInt(c)
    c.toInt() - '0'.toInt()

def charIsInt(c)
    c >= '0' && c <= '9'

def ifHasNext(lazy then, lazy f)
    {hasNext().not()}.if(then(), f())

def skipIgnored()
    {hasNext() && peek() == ' '}.if({
        next()
        skipIgnored()
    }, {})

def parseIntExpr() {
    def go(sum) 
        {hasNext() && charIsInt(peek())}.if({
            let char peek()
            next()
            go(sum * 10 + charToInt(char))
        }, sum)
    IntExpr(go(0))
}

class ParseError(string)
def ParseError.toString() this.string

def parseParens() {
    let expr parseAddExpr();
    {peek() != ')'}.if(do ParseError("Expected ')'")) {
        next()
        expr
    }
}

def charIsIdent(c)
    c >= 'a' && c <= 'z'

def parseIdentExpr() {
    def go(ident) 
        {hasNext() && charIsIdent(peek())}.if({
            let char peek()
            next()
            go(ident + char.toString())
        }, ident)
    IdentExpr(go(""))
}

def parseLambdaExpr() {
    let ident parseIdentExpr()
    skipIgnored()
    LambdaExpr(ident.name, parseAddExpr())
}

def parseAtomicExpr() {
    skipIgnored()
    ifHasNext(do ParseError("Unexpected end of reader")) {
        {peek() == '('}.if({ next() parseParens() }) {
            {peek() == '\\'}.if({ next() parseLambdaExpr() }) {
                {charIsInt(peek())}.if(parseIntExpr()) {
                    {charIsIdent(peek())}.if(parseIdentExpr()) {
                        do ParseError("Unexpected character")
                    }
                }
            }
        }
    }
}

def parseApplyExpr() {
    let expr parseAtomicExpr()
    skipIgnored()
    ifHasNext(expr) {
        {peek() == '$'}.if({
            next()
            ApplyExpr(expr, parseAtomicExpr())
        }, expr)
    }
}

def parseMulExpr() {
    let expr parseApplyExpr()
    skipIgnored()
    ifHasNext(expr) {
        {peek() == '*'}.if({
            next()
            MulExpr(expr, parseMulExpr())
        }, expr)
    }
}

def parseAddExpr() {
    let expr parseMulExpr()
    skipIgnored()
    ifHasNext(expr) {
        {peek() == '+'}.if({
            next()
            AddExpr(expr, parseAddExpr())
        }, expr)
    }
}

def eval(string)
    readString(string, 0, parseAddExpr()).evalRoot()
